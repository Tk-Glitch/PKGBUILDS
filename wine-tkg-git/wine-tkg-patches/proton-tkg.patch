From aa88eb017be4c3615d0f8aab8a2e16769a6568ad Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 27 Dec 2017 13:31:59 -0600
Subject: [PATCH] loader: Set up Steam stuff in the registry

---
 loader/wine.inf.in | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5767b29887c..75d5f4a7216 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -75,7 +75,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient
 
 [DefaultInstall.ntamd64]
 RegisterDlls=RegisterDllsSection
@@ -103,7 +104,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [Wow64Install]
 RegisterDlls=RegisterDllsSection
@@ -118,7 +120,8 @@ AddReg=\
     Misc,\
     Tapi,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [DefaultInstall.Services]
 AddService=BITS,0,BITSService
@@ -3518,3 +3521,13 @@ HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-Shanghai-EnableGame",0x1
 HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-Solitaire-EnableGame",0x10001,0x00000001
 HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-SpiderSolitaire-EnableGame",0x10001,0x00000001
 HKLM,Software\Wine\LicenseInformation,"Shell-PremiumInBoxGames-Chess-EnableGame",0x10001,0x00000001
+
+[SteamClient]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16422%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
+
+[SteamClient.ntamd64]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"

From bc614834ee153ce33449c06e697b4a30748e9257 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 27 Apr 2017 13:25:04 -0500
Subject: [PATCH] HACK kernel32: Substitute the current pid for the Steam
 client pid

---
 dlls/kernel32/process.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 85e0042024c..9c957f02c06 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -3001,6 +3001,22 @@ HANDLE WINAPI OpenProcess( DWORD access, BOOL inherit, DWORD id )
     OBJECT_ATTRIBUTES   attr;
     CLIENT_ID           cid;
 
+    if(id == 0xfffe)
+        /* STEAMOS HACK:
+         * On Windows, the Steam client puts its process ID into the registry
+         * at:
+         *
+         *   [HKCU\Software\Valve\Steam\ActiveProcess]
+         *   PID=dword:00000008
+         *
+         * Games get that pid from the registry and then query it with
+         * OpenProcess to ensure Steam is running. Since we aren't running the
+         * Windows Steam in Wine, instead we hack this magic number into the
+         * registry and then substitute the game's process itself in its place
+         * so it can query a valid process.
+         */
+        id = GetCurrentProcessId();
+
     cid.UniqueProcess = ULongToHandle(id);
     cid.UniqueThread = 0; /* FIXME ? */
 
From a277e32030a31abe90af9d38462f1159bc94b7b0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:50:08 -0500
Subject: [PATCH] HACK: kernel32: Swap requests for steamclient.dll with
 lsteamclient

---
 dlls/kernel32/module.c | 63 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 118829895b7..cf3a0b5ed98 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,6 +76,23 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
+static HMODULE steamclient_hmod = NULL;
+static HMODULE lsteamclient_hmod = NULL;
+
+static WCHAR *strcasestrW( const WCHAR *str, const WCHAR *sub )
+{
+    while (*str)
+    {
+        const WCHAR *p1 = str, *p2 = sub;
+        while (*p1 && *p2 && tolowerW(*p1) == tolowerW(*p2)) { p1++; p2++; }
+        if (!*p2) return (WCHAR *)str;
+        str++;
+    }
+    return NULL;
+}
+
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
  */
@@ -710,6 +727,10 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     else
     {
         UNICODE_STRING wstr;
+        if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
+            *module = steamclient_hmod;
+            return TRUE;
+        }
         RtlInitUnicodeString( &wstr, name );
         status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
     }
@@ -818,6 +839,11 @@ DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size
     NTSTATUS nts;
     WIN16_SUBSYSTEM_TIB *win16_tib;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod){
+        memcpy(lpFileName, steamclient_pathW, sizeof(steamclient_pathW));
+        return sizeof(steamclient_pathW)/sizeof(WCHAR);
+    }
+
     if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
     {
         len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
@@ -1194,6 +1220,7 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     NTSTATUS nts;
     HMODULE hModule;
     WCHAR *load_path;
+    const WCHAR *p;
     const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
                                              LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
                                              LOAD_LIBRARY_SEARCH_USER_DIRS |
@@ -1207,6 +1234,36 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     if( flags & unsupported_flags)
         FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
 
+    if((p = strcasestrW(libname->Buffer, steamclientW)) &&
+            (p == libname->Buffer ||
+             *(p - 1) != 'l')){
+
+        if(!lsteamclient_hmod)
+            lsteamclient_hmod = LoadLibraryA("lsteamclient.dll");
+
+        if(!steamclient_hmod){
+            HANDLE f = CreateFileW(steamclient_pathW,
+                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                    NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+            if(f != INVALID_HANDLE_VALUE){
+                DWORD sz, readed;
+
+                sz = GetFileSize(f, NULL);
+
+                steamclient_hmod = HeapAlloc(GetProcessHeap(), 0, sz);
+                ReadFile(f, steamclient_hmod, sz, &readed, NULL);
+
+                CloseHandle(f);
+            }else{
+                /* this will fail DRM checks, but otherwise should work */
+                ERR("somehow failed to load steamclient\n");
+                steamclient_hmod = lsteamclient_hmod;
+            }
+        }
+
+        return steamclient_hmod;
+    }
+
     if (flags & load_library_search_flags)
         load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
     else
@@ -1362,6 +1419,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
         return FALSE;
     }
 
+    if(steamclient_hmod != NULL && hLibModule == steamclient_hmod)
+        return TRUE;
+
     if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
     {
         if ((ULONG_PTR)hLibModule & 1)
@@ -1410,6 +1470,9 @@ FARPROC get_proc_address( HMODULE hModule, LPCSTR function )
 
     if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod)
+        hModule = lsteamclient_hmod;
+
     if ((ULONG_PTR)function >> 16)
     {
         ANSI_STRING     str;

From acda0915ca65ea7e818fbb89bae14894602cf845 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 5 Jun 2017 14:41:28 -0500
Subject: [PATCH] HACK: kernel32: Load hard-coded Steam.dll path if relative
 load fails

Some games (Call of Duty is one example) try to just
LoadLibrary("Steam.dll") with no path. If that fails, it complains
"Failed to find Steam". This works on Windows because Steam sets the
PATH environment variable to include <C:\Program Files\Steam\>, which is
where Steam.dll lives, before launching the game. However, the Linux
Steam obviously doesn't do that. For this reason, we place Steam.dll in
there and this hack loads it correctly for the games.

TODO: is this enough? Should we put that path into PATH like on Windows,
in case it tries to load other binaries?
---
 dlls/kernel32/module.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index cf3a0b5ed98..6ca438d3ae2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -77,6 +77,8 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
+static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -1302,6 +1304,12 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     }
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
+
+    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
+        /* tried and failed to load Steam.dll from PATH. try again
+         * with known-good path */
+        return LoadLibraryW(full_steamdllW);
+
     return hModule;
 }
 
From 183eac81ab4739735c4f49d25c1384d98f17655d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 9 Jun 2017 10:31:27 -0500
Subject: [PATCH] HACK: kernel32: Return steamclient instead of lsteamclient
 during GetModuleHandleEx

Found a game which passes the result from GetProcAddress to this. Ugh.
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 6ca438d3ae2..a1a2b0e100c 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -725,6 +725,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     {
         void *dummy;
         if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+        if(steamclient_hmod != NULL && ret == lsteamclient_hmod)
+            ret = steamclient_hmod;
     }
     else
     {

From 3835eee939a9e8c6a8f29733307a8531053a3616 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 13 Jun 2017 12:35:56 -0500
Subject: [PATCH] HACK: kernel32: Put Steam program files dir into PATH

---
 dlls/kernel32/module.c | 23 +++++++++++++++++------
 1 file changed, 17 insertions(+), 6 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index a1a2b0e100c..ef0295081c8 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -78,7 +78,7 @@ static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
-static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
+static const DWORD steamdllW_len = 9;
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -890,12 +890,18 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
+        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
+        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
-        int len = 1;
+        int len = 2;
 
+        len += steamProgramPathW_len;
         len += 2 * GetSystemDirectoryW( NULL, 0 );
         len += GetWindowsDirectoryW( NULL, 0 );
         p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        strcpyW(p, steamProgramPathW);
+        p += steamProgramPathW_len;
+        *p++ = ';';
         GetSystemDirectoryW( p, path + len - p);
         p += strlenW(p);
         /* if system directory ends in "32" add 16-bit version too */
@@ -1307,10 +1313,15 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
-        /* tried and failed to load Steam.dll from PATH. try again
-         * with known-good path */
-        return LoadLibraryW(full_steamdllW);
+    if(!hModule){
+        DWORD len = lstrlenW(libname->Buffer);
+        if(len > steamdllW_len &&
+                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
+            /* tried and failed to load some path ending in Steam.dll. try
+             * again without hard-coded path */
+            return LoadLibraryW(steamdllW);
+        }
+    }
 
     return hModule;
 }

From a2f9e2806acdd83aa9121baea4a8a908e2a9e909 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 28 Dec 2017 09:43:36 -0600
Subject: [PATCH] kernel32: Support steamclient64

---
 dlls/kernel32/module.c | 11 ++++++++---
 loader/wine.inf.in     |  1 +
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ef0295081c8..32f9ddf6718 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,10 +76,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+#if defined(__x86_64__)
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t','6','4',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','6','4','.','d','l','l',0};
+#else
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};
+#endif
+static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m',0};
+static const DWORD steamProgramPathW_len = 28;
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
 static const DWORD steamdllW_len = 9;
-static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
 
@@ -890,8 +897,6 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
-        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
-        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
         int len = 2;
 
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 75d5f4a7216..7fe2f49dcd9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3530,4 +3530,5 @@ HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
 [SteamClient.ntamd64]
 HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"

From bf02d103fde2c2e54a074b03021f47e4672d4b01 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Nov 2018 18:45:57 +0300
Subject: [PATCH] Add missing InstallPath registry value.

So UPlay won't try to install Steam.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5610c701d..3d71722ac 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3784,3 +3784,4 @@ HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+HKLM,Software\Wow6432Node\Valve\Steam,"InstallPath",,"%16422%\Steam"

From bac899cd4531229baa7633d67578b74a2a98468f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 19 Mar 2018 11:34:35 -0500
Subject: [PATCH] kernel32: Don't force-load Steam.dll

This must fail for older DRM which walks up the FS tree searching for
Steam.dll to work correctly.
---
 dlls/kernel32/module.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 32f9ddf6718..342e408b555 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1318,16 +1318,6 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule){
-        DWORD len = lstrlenW(libname->Buffer);
-        if(len > steamdllW_len &&
-                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
-            /* tried and failed to load some path ending in Steam.dll. try
-             * again without hard-coded path */
-            return LoadLibraryW(steamdllW);
-        }
-    }
-
     return hModule;
 }
 
From 7bd039f34f5fc1123524ddb22769f6e16e7d9c88 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:01:16 -0500
Subject: [PATCH] HACK: ws2_32: Fake success when trying to bind to an IPX
 address

---
 dlls/ws2_32/socket.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 164a48ce751..b9248c9bd5e 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3332,6 +3332,13 @@ int WINAPI WS_bind(SOCKET s, const struct WS_sockaddr* name, int namelen)
                     else if (interface_bind(s, fd, &uaddr.addr))
                         in4->sin_addr.s_addr = htonl(INADDR_ANY);
                 }
+
+                if(name->sa_family ==  WS_AF_IPX){
+                    /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+                     * doesn't work on Linux, so just fake success. */
+                    return 0;
+                }
+
                 if (bind(fd, &uaddr.addr, uaddrlen) < 0)
                 {
                     int loc_errno = errno;

From 819b923a3b761944b094f5f20b881c501a522f20 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 19 Jan 2018 14:01:07 -0600
Subject: [PATCH] HACK: advapi32: Use steamuser as Wine username

---
 dlls/advapi32/advapi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/advapi32/advapi.c b/dlls/advapi32/advapi.c
index 1c528ef7419..87792f4fbc9 100644
--- a/dlls/advapi32/advapi.c
+++ b/dlls/advapi32/advapi.c
@@ -84,7 +84,7 @@ GetUserNameA( LPSTR lpszName, LPDWORD lpSize )
 BOOL WINAPI
 GetUserNameW( LPWSTR lpszName, LPDWORD lpSize )
 {
-    const char *name = wine_get_user_name();
+    const char *name = "steamuser"/*wine_get_user_name()*/;
     DWORD i, len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
     LPWSTR backslash;
 
From ec9e7190ea7045012b6e33e5ee64cd678bec68c9 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 22 Jan 2018 14:32:40 -0600
Subject: [PATCH] HACK: shell32: Never create links to the user's home dirs

---
 dlls/shell32/shellpath.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index f08474b3635..2f637f25537 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -4424,6 +4424,7 @@ static void _SHCreateSymbolicLinks(void)
     pszPersonal = wine_get_unix_file_name(wszTempPath);
     if (!pszPersonal) return;
 
+#if 0
     hr = XDG_UserDirLookup(xdg_dirs, num, &xdg_results);
     if (FAILED(hr)) xdg_results = NULL;
 
@@ -4477,6 +4478,7 @@ static void _SHCreateSymbolicLinks(void)
     }
     else
     {
+#endif
         /* '$HOME' doesn't exist. Create 'My Pictures', 'My Videos' and 'My Music' subdirs
          * in '%USERPROFILE%\\My Documents' or fail silently if they already exist. */
         pszHome = NULL;
@@ -4486,8 +4488,11 @@ static void _SHCreateSymbolicLinks(void)
             if (_SHAppendToUnixPath(szMyStuffTarget, MAKEINTRESOURCEW(aidsMyStuff[i])))
                 mkdir(szMyStuffTarget, 0777);
         }
+#if 0
     }
+#endif
 
+#if 0
     /* Create symbolic links for 'My Pictures', 'My Videos' and 'My Music'. */
     for (i=0; i < ARRAY_SIZE(aidsMyStuff); i++)
     {
@@ -4532,13 +4537,17 @@ static void _SHCreateSymbolicLinks(void)
         symlink(szMyStuffTarget, pszMyStuff);
         heap_free(pszMyStuff);
     }
+#endif
 
+#if 0
     /* Last but not least, the Desktop folder */
     if (pszHome)
         strcpy(szDesktopTarget, pszHome);
     else
         strcpy(szDesktopTarget, pszPersonal);
+#endif
     heap_free(pszPersonal);
+#if 0
 
     xdg_desktop_dir = xdg_results ? xdg_results[num - 1] : NULL;
     if (xdg_desktop_dir ||
@@ -4565,6 +4574,7 @@ static void _SHCreateSymbolicLinks(void)
             heap_free(xdg_results[i]);
         heap_free(xdg_results);
     }
+#endif
 }
 
 /******************************************************************************

From 134fa05a0e39b63bfec75d0823ebe49e4c9cae64 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 7 Jun 2018 14:37:03 -0500
Subject: [PATCH] HACK: winex11.drv: Disable XIM by default

libx11 has a race condition that causes XIM to crash with "double free
or corruption" errors, see winehq bug 35041. Disabling XIM works around
this, though special input methods (CJK, etc.) will no longer work.
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index db87d188236..81a63a20689 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -93,7 +93,7 @@ static void *err_callback_arg;               /* error callback argument */
 static int err_callback_result;              /* error callback result */
 static unsigned long err_serial;             /* serial number of first request */
 static int (*old_error_handler)( Display *, XErrorEvent * );
-static BOOL use_xim = TRUE;
+static BOOL use_xim = FALSE;
 static char input_style[20];
 
 #define IS_OPTION_TRUE(ch) \

From d012d137e4099d1b12079a49a8a5632d205e0a9f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 24 Sep 2018 12:37:49 -0500
Subject: [PATCH] HACK: dbghelp: Disable DWARF parsing

Patch by Zeb. Our DWARF parser has been known to crash winedbg in some
cases. Since probably no concerned parties are going to be using plain
winedbg, just don't bother parsing anything.
---
 dlls/dbghelp/dwarf.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 31c008abb8f..ce689dbe6cf 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -3516,6 +3516,11 @@ BOOL dwarf2_parse(struct module* module, unsigned long load_offset,
     BOOL                ret = TRUE;
     struct module_format* dwarf2_modfmt;
 
+/* Our DWARF parser has been known to crash winedbg in some cases. Since
+ * probably no concerned parties are going to be using plain winedbg, just don't
+ * bother parsing anything. */
+return FALSE;
+
     dwarf2_init_section(&eh_frame,                fmap, ".eh_frame",     NULL,             &eh_frame_sect);
     dwarf2_init_section(&section[section_debug],  fmap, ".debug_info",   ".zdebug_info",   &debug_sect);
     dwarf2_init_section(&section[section_abbrev], fmap, ".debug_abbrev", ".zdebug_abbrev", &debug_abbrev_sect);

From a13270aea50af90aa6c721080b956870d67d81c2 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Mar 2018 10:40:43 -0500
Subject: [PATCH] winedbg: When crash dialog is not shown, dump crash info to
 stderr

This way the backtrace and such will appear in the log file instead of
going to stdout, which we don't capture.
---
 programs/winedbg/tgt_active.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/programs/winedbg/tgt_active.c b/programs/winedbg/tgt_active.c
index f632ca0414d..72e63327831 100644
--- a/programs/winedbg/tgt_active.c
+++ b/programs/winedbg/tgt_active.c
@@ -874,6 +874,9 @@ enum dbg_start dbg_active_auto(int argc, char* argv[])
         if (event) thread = display_crash_details( event );
         if (thread) dbg_houtput = output = create_temp_file();
         break;
+    case TRUE:
+        dbg_houtput = GetStdHandle(STD_ERROR_HANDLE);
+        break;
     }
 
     input = parser_generate_command_file("echo Modules:", "info share",

From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }
 
     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From 29a2c4f1b8cad98e94c67e4c068d9096969074ee Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 20 Aug 2018 10:58:09 -0500
Subject: [PATCH] secur32: Return real Unix username from
 GetUserNameEx(NameDisplay)

---
 dlls/secur32/secur32.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/secur32/secur32.c b/dlls/secur32/secur32.c
index ec189fda104..1c662adf44b 100644
--- a/dlls/secur32/secur32.c
+++ b/dlls/secur32/secur32.c
@@ -34,6 +34,7 @@
 #include "thunks.h"
 #include "lmcons.h"
 
+#include "wine/library.h"
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
@@ -1201,9 +1202,25 @@ BOOLEAN WINAPI GetUserNameExW(
             return FALSE;
         }
 
+    case NameDisplay:
+        {
+            const char *name = wine_get_user_name();
+            DWORD len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
+
+            if (len > *nSize)
+            {
+                SetLastError( ERROR_MORE_DATA );
+                *nSize = len;
+                return FALSE;
+            }
+
+            *nSize = len - 1;
+            MultiByteToWideChar( CP_UNIXCP, 0, name, -1, lpNameBuffer, len );
+            return TRUE;
+        }
+
     case NameUnknown:
     case NameFullyQualifiedDN:
-    case NameDisplay:
     case NameUniqueId:
     case NameCanonical:
     case NameUserPrincipal:


From 63f934962cb97d69ed71604985716e7479f822b1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 23 Oct 2018 16:18:20 +0300
Subject: [PATCH] wine.inf: Add font registry entries.

---
 loader/wine.inf.in | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 1f94c38d0c6..df2b43d9106 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -181,6 +181,7 @@ CurrentVersion="Software\Microsoft\Windows\CurrentVersion"
 CurrentVersionNT="Software\Microsoft\Windows NT\CurrentVersion"
 FontSubStr="Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes"
 Control="System\CurrentControlSet\Control"
+FontsNT="Software\Microsoft\Windows NT\CurrentVersion\Fonts"
 
 [Classes]
 HKCR,.chm,,2,"chm.file"
@@ -614,6 +615,10 @@ HKLM,%FontSubStr%,"Times New Roman CYR,204",,"Times New Roman,204"
 HKLM,%FontSubStr%,"Times New Roman Greek,161",,"Times New Roman,161"
 HKLM,%FontSubStr%,"Times New Roman TUR,162",,"Times New Roman,162"
 HKLM,System\CurrentControlSet\Hardware Profiles\Current\Software\Fonts,"LogPixels",0x10003,0x00000060
+HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
+HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
+HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
+HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"
     
From 174d487bf8ef5bec22c3663f50a276ae59d0a931 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 30 Oct 2018 13:04:06 -0500
Subject: [PATCH] wine.inf: Substitute Times New Roman for Palatino Linotype

For AOE2HD launcher.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index df2b43d9106..44ce3cd6639 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -619,6 +619,7 @@ HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
 HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
 HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
 HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
+HKCU,Software\Wine\Fonts\Replacements,"Palatino Linotype",,"Times New Roman"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
 /* parse-line args */

From 059a15a1d521a6ba79273b2ade923822b1532205 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 13 Jul 2018 10:40:27 -0500
Subject: [PATCH] HACK: mshtml: Don't install wine-gecko on prefix creation

We only want to install this on demand.
---
 dlls/mshtml/main.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index 6ce8198aee5..f84d92cc860 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -530,8 +530,6 @@ HRESULT WINAPI DllRegisterServer(void)
     hres = __wine_register_resources( hInst );
     if(SUCCEEDED(hres))
         hres = register_server(TRUE);
-    if(SUCCEEDED(hres))
-        load_gecko();
 
     return hres;
 }

From 1ef83da3b15171782dc009bb6649665769122aa5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 15 Jan 2019 10:10:47 -0600
Subject: [PATCH] kernel32: Don't pass SDL_AUDIODRIVER from Linux environment

---
 dlls/kernel32/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 9c957f02c06..e14b514ccc1 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -137,6 +137,7 @@ static inline BOOL is_special_env_var( const char *var )
             !strncmp( var, "TEMP=", sizeof("TEMP=")-1 ) ||
             !strncmp( var, "TMP=", sizeof("TMP=")-1 ) ||
             !strncmp( var, "QT_", sizeof("QT_")-1 ) ||
+            !strncmp( var, "SDL_AUDIODRIVER=", sizeof("SDL_AUDIODRIVER=")-1 ) ||
             !strncmp( var, "VK_", sizeof("VK_")-1 ));
 }
 
From 59e3f7faf3aca068ca37ad274490e4d7bcd85907 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 11 Jun 2018 13:40:24 -0500
Subject: [PATCH] kernel32: Implement Set and GetThreadDescription

---
 dlls/kernel32/kernel32.spec  |   2 +
 dlls/kernel32/tests/thread.c |  46 ++++++++++++++
 dlls/kernel32/thread.c       | 112 ++++++++++++++++++++++++++++++++---
 include/winbase.h            |   2 +
 4 files changed, 154 insertions(+), 8 deletions(-)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index f1d75b8e1c6..98f37215756 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -847,6 +847,7 @@
 @ stdcall GetTempPathA(long ptr)
 @ stdcall GetTempPathW(long ptr)
 @ stdcall GetThreadContext(long ptr)
+@ stdcall GetThreadDescription(long ptr)
 @ stdcall GetThreadErrorMode()
 @ stdcall GetThreadGroupAffinity(long ptr)
 @ stdcall GetThreadId(ptr)
@@ -1447,6 +1448,7 @@
 @ stdcall SetTermsrvAppInstallMode(long)
 @ stdcall SetThreadAffinityMask(long long)
 @ stdcall SetThreadContext(long ptr)
+@ stdcall SetThreadDescription(long ptr)
 @ stdcall SetThreadErrorMode(long ptr)
 @ stdcall SetThreadExecutionState(long)
 @ stdcall SetThreadGroupAffinity(long ptr ptr)
diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index b69d2eb371f..2be405e7ae7 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -102,6 +102,8 @@ static NTSTATUS (WINAPI *pNtQueryInformationThread)(HANDLE,THREADINFOCLASS,PVOID
 static BOOL (WINAPI *pGetThreadGroupAffinity)(HANDLE,GROUP_AFFINITY*);
 static BOOL (WINAPI *pSetThreadGroupAffinity)(HANDLE,const GROUP_AFFINITY*,GROUP_AFFINITY*);
 static NTSTATUS (WINAPI *pNtSetInformationThread)(HANDLE,THREADINFOCLASS,LPCVOID,ULONG);
+static HRESULT (WINAPI *pSetThreadDescription)(HANDLE,const WCHAR *);
+static HRESULT (WINAPI *pGetThreadDescription)(HANDLE,WCHAR **);
 
 static HANDLE create_target_process(const char *arg)
 {
@@ -1594,6 +1596,47 @@ static void test_ThreadErrorMode(void)
     pSetThreadErrorMode(oldmode, NULL);
 }
 
+static void test_ThreadDescription(void)
+{
+    HRESULT hr;
+    static const WCHAR test_nameW[] = {'t','e','s','t','_','n','a','m','e',0};
+    static const WCHAR emptyW[] = {0};
+    WCHAR *out;
+
+    if (!pSetThreadDescription)
+    {
+        win_skip("SetThreadDescription not implemented\n");
+        return;
+    }
+
+    if(0)
+    {
+        /* crash on win10 */
+        hr = pGetThreadDescription(GetCurrentThread(), NULL);
+    }
+
+    hr = pGetThreadDescription(GetCurrentThread(), &out);
+    ok(hr == 0x10000000, "GetThreadDescription failed: 0x%x\n", hr);
+    todo_wine ok(!lstrcmpW(out, emptyW), "Got non-empty thread name: %s\n", wine_dbgstr_w(out));
+    LocalFree(out);
+
+    hr = pSetThreadDescription(GetCurrentThread(), test_nameW);
+    ok(hr == 0x10000000, "SetThreadDescription failed: 0x%x\n", hr);
+
+    hr = pGetThreadDescription(GetCurrentThread(), &out);
+    ok(hr == 0x10000000, "GetThreadDescription failed: 0x%x\n", hr);
+    ok(!lstrcmpW(test_nameW, out), "Got wrong thread name: %s\n", wine_dbgstr_w(out));
+    LocalFree(out);
+
+    hr = pSetThreadDescription(GetCurrentThread(), NULL);
+    ok(hr == 0x10000000, "SetThreadDescription should have failed: 0x%x\n", hr);
+
+    hr = pGetThreadDescription(GetCurrentThread(), &out);
+    ok(hr == 0x10000000, "GetThreadDescription failed: 0x%x\n", hr);
+    ok(!lstrcmpW(emptyW, out), "Got wrong thread name: %s\n", wine_dbgstr_w(out));
+    LocalFree(out);
+}
+
 #if (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))) || (defined(_MSC_VER) && defined(__i386__))
 static inline void set_fpu_cw(WORD cw)
 {
@@ -2024,6 +2067,8 @@ static void init_funcs(void)
 
     X(GetThreadGroupAffinity);
     X(SetThreadGroupAffinity);
+    X(SetThreadDescription);
+    X(GetThreadDescription);
 
     X(FlsAlloc);
     X(FlsFree);
@@ -2096,6 +2141,7 @@ START_TEST(thread)
    test_TLS();
    test_FLS();
    test_ThreadErrorMode();
+   test_ThreadDescription();
 #if (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))) || (defined(_MSC_VER) && defined(__i386__))
    test_thread_fpu_cw();
 #endif
diff --git a/dlls/kernel32/thread.c b/dlls/kernel32/thread.c
index a86ad3443a4..6cc11a69fed 100644
--- a/dlls/kernel32/thread.c
+++ b/dlls/kernel32/thread.c
@@ -28,6 +28,9 @@
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
+#ifdef HAVE_SYS_PRCTL_H
+# include <sys/prctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -35,6 +38,7 @@
 #include "winbase.h"
 #include "winerror.h"
 #include "winternl.h"
+#include "winnls.h"
 #include "wine/exception.h"
 #include "wine/library.h"
 #include "wine/server.h"
@@ -269,20 +273,112 @@ BOOL WINAPI GetThreadContext( HANDLE handle,     /* [in]  Handle to thread with
 
 
 /***********************************************************************
- * Wow64GetThreadContext [KERNEL32.@]
- */
+* Wow64GetThreadContext [KERNEL32.@]
+*/
 BOOL WINAPI Wow64GetThreadContext( HANDLE handle, WOW64_CONTEXT *context)
 {
 #ifdef __i386__
-    NTSTATUS status = NtGetContextThread( handle, (CONTEXT *)context );
+NTSTATUS status = NtGetContextThread( handle, (CONTEXT *)context );
 #elif defined(__x86_64__)
-    NTSTATUS status = RtlWow64GetThreadContext( handle, context );
+NTSTATUS status = RtlWow64GetThreadContext( handle, context );
 #else
-    NTSTATUS status = STATUS_NOT_IMPLEMENTED;
-    FIXME("not implemented on this platform\n");
+NTSTATUS status = STATUS_NOT_IMPLEMENTED;
+FIXME("not implemented on this platform\n");
 #endif
-    if (status) SetLastError( RtlNtStatusToDosError(status) );
-    return !status;
+if (status) SetLastError( RtlNtStatusToDosError(status) );
+return !status;
+}
+
+
+/* ??? MSDN says it should be HRESULT, but we get this */
+#define THREADDESC_SUCCESS 0x10000000
+
+/***********************************************************************
+* SetThreadDescription [KERNEL32.@]  Sets name of thread.
+*
+* RETURNS
+*    Success: TRUE
+*    Failure: FALSE
+*/
+HRESULT WINAPI SetThreadDescription( HANDLE handle, const WCHAR *descW )
+{
+TRACE("(%p,%s)\n", handle, wine_dbgstr_w( descW ));
+
+if (handle != GetCurrentThread())
+{
+    FIXME("Can't set other thread description\n");
+    return THREADDESC_SUCCESS;
+}
+
+#ifdef HAVE_PRCTL
+
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+
+if (descW)
+{
+    DWORD length;
+    char *descA;
+
+    length = WideCharToMultiByte( CP_UNIXCP, 0, descW, -1, NULL, 0, NULL, NULL );
+    if (!(descA = HeapAlloc( GetProcessHeap(), 0, length ))) return E_OUTOFMEMORY;
+    WideCharToMultiByte( CP_UNIXCP, 0, descW, -1, descA, length, NULL, NULL );
+
+    prctl( PR_SET_NAME, descA );
+
+    HeapFree( GetProcessHeap(), 0, descA );
+}
+else
+    prctl( PR_SET_NAME, "" );
+
+#endif  /* HAVE_PRCTL */
+
+return THREADDESC_SUCCESS;
+}
+
+
+/***********************************************************************
+* GetThreadDescription [KERNEL32.@]  Retrieves name of thread.
+*
+* RETURNS
+*    Success: TRUE
+*    Failure: FALSE
+*/
+HRESULT WINAPI GetThreadDescription( HANDLE handle, WCHAR **descW )
+{
+#ifdef HAVE_PRCTL
+char descA[16];
+#endif
+
+*descW = LocalAlloc( 0, 16 * sizeof(WCHAR) );
+if(!*descW)
+    return E_OUTOFMEMORY;
+
+if (handle != GetCurrentThread())
+{
+    FIXME("Can't get other thread description\n");
+    (*descW)[0] = 0;
+    return THREADDESC_SUCCESS;
+}
+
+#ifdef HAVE_PRCTL
+#ifndef PR_GET_NAME
+# define PR_GET_NAME 16
+#endif
+
+    if (prctl( PR_GET_NAME, descA ) != 0)
+    {
+        (*descW)[0] = 0;
+        return THREADDESC_SUCCESS;
+    }
+
+    MultiByteToWideChar( CP_UNIXCP, 0, descA, -1, *descW, 16 );
+#else
+    (*descW)[0] = 0;
+#endif
+
+    return THREADDESC_SUCCESS;
 }
 
 
diff --git a/include/winbase.h b/include/winbase.h
index 8b26308b956..bfbc81ca098 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -2247,6 +2247,7 @@ WINBASEAPI DWORD       WINAPI GetTickCount(void);
 WINBASEAPI ULONGLONG   WINAPI GetTickCount64(void);
 WINBASEAPI DWORD       WINAPI GetTimeZoneInformation(LPTIME_ZONE_INFORMATION);
 WINBASEAPI BOOL        WINAPI GetThreadContext(HANDLE,CONTEXT *);
+WINBASEAPI HRESULT     WINAPI GetThreadDescription(HANDLE,WCHAR **);
 WINBASEAPI DWORD       WINAPI GetThreadErrorMode(void);
 WINBASEAPI INT         WINAPI GetThreadPriority(HANDLE);
 WINBASEAPI BOOL        WINAPI GetThreadPriorityBoost(HANDLE,PBOOL);
@@ -2612,6 +2613,7 @@ WINBASEAPI DWORD       WINAPI SetTapeParameters(HANDLE,DWORD,LPVOID);
 WINBASEAPI DWORD       WINAPI SetTapePosition(HANDLE,DWORD,DWORD,DWORD,DWORD,BOOL);
 WINBASEAPI DWORD_PTR   WINAPI SetThreadAffinityMask(HANDLE,DWORD_PTR);
 WINBASEAPI BOOL        WINAPI SetThreadContext(HANDLE,const CONTEXT *);
+WINBASEAPI HRESULT     WINAPI SetThreadDescription(HANDLE,const WCHAR *);
 WINBASEAPI BOOL        WINAPI SetThreadErrorMode(DWORD,LPDWORD);
 WINBASEAPI DWORD       WINAPI SetThreadExecutionState(EXECUTION_STATE);
 WINBASEAPI DWORD       WINAPI SetThreadIdealProcessor(HANDLE,DWORD);

From 971dc3c4225b33fb5346187cd37e8355f265800f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/exception.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index f85381079a2..ffe048de8c0 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -26,6 +26,9 @@
 #include <errno.h>
 #include <signal.h>
 #include <stdarg.h>
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -143,6 +146,16 @@ void wait_suspend( CONTEXT *context )
 }
 
 
+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -162,6 +175,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *con
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];
 
+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     context_to_server( &server_context, context );
 
     SERVER_START_REQ( queue_exception_event )

From a7542e9e279970c2ab3ac9c6c986b300135286a0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:17:30 -0500
Subject: [PATCH] wine.inf: Don't show crash dialog by default

---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 7fe2f49dcd9..e72d0dcaba1 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -540,6 +540,7 @@ HKLM,%CurrentVersionNT%\AeDebug,"Debugger",2,"winedbg --auto %ld %ld"
 HKLM,%CurrentVersionNT%\AeDebug,"Auto",2,"1"
 HKCU,Software\Wine\Debug,"RelayExclude",2,"ntdll.RtlEnterCriticalSection;ntdll.RtlTryEnterCriticalSection;ntdll.RtlLeaveCriticalSection;kernel32.48;kernel32.49;kernel32.94;kernel32.95;kernel32.96;kernel32.97;kernel32.98;kernel32.TlsGetValue;kernel32.TlsSetValue;kernel32.FlsGetValue;kernel32.FlsSetValue;kernel32.SetLastError"
 HKCU,Software\Wine\Debug,"RelayFromExclude",2,"winex11.drv;winemac.drv;user32;gdi32;advapi32;kernel32"
+HKCU,Software\Wine\WineDbg,"ShowCrashDialog",0x00010003,0x00000000
 
 [DirectX]
 HKLM,Software\Microsoft\DirectX,"Version",,"4.09.00.0904"

From 71fce64369f2ace00bc0bb8018b549dd201a5764 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 9 Jan 2019 13:24:54 +0300
Subject: [PATCH] imm32: Automatically initialize COM on window activation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/imm32/Makefile.in     |   2 +-
 dlls/imm32/imm.c           | 129 ++++++++++++++++++++++++++++++++++++-
 dlls/imm32/imm32.spec      |   1 +
 dlls/user32/focus.c        |   2 +
 dlls/user32/misc.c         |   2 +
 dlls/user32/user_private.h |   1 +
 6 files changed, 135 insertions(+), 2 deletions(-)

diff --git a/dlls/imm32/Makefile.in b/dlls/imm32/Makefile.in
index b190888659b..ad10fc2fa45 100644
--- a/dlls/imm32/Makefile.in
+++ b/dlls/imm32/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = imm32.dll
 IMPORTLIB = imm32
-IMPORTS   = user32 gdi32 advapi32
+IMPORTS   = user32 gdi32 advapi32 ole32
 
 C_SRCS = \
 	imm.c
diff --git a/dlls/imm32/imm.c b/dlls/imm32/imm.c
index 28eb00f355a..129f7e8cb53 100644
--- a/dlls/imm32/imm.c
+++ b/dlls/imm32/imm.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define COBJMACROS
+
 #include <stdarg.h>
 #include <stdio.h>
 
@@ -32,6 +34,8 @@
 #include "ddk/imm.h"
 #include "winnls.h"
 #include "winreg.h"
+#include "initguid.h"
+#include "objbase.h"
 #include "wine/list.h"
 #include "wine/unicode.h"
 
@@ -95,8 +99,16 @@ typedef struct _tagIMMThreadData {
     HWND hwndDefault;
     BOOL disableIME;
     DWORD windowRefs;
+    IInitializeSpy IInitializeSpy_iface;
+    ULARGE_INTEGER spy_cookie;
+    BOOL apt_initialized;
 } IMMThreadData;
 
+static inline IMMThreadData *impl_from_IInitializeSpy(IInitializeSpy *iface)
+{
+    return CONTAINING_RECORD(iface, IMMThreadData, IInitializeSpy_iface);
+}
+
 static struct list ImmHklList = LIST_INIT(ImmHklList);
 static struct list ImmThreadDataList = LIST_INIT(ImmThreadDataList);
 
@@ -227,6 +239,88 @@ static DWORD convert_candidatelist_AtoW(
     return ret;
 }
 
+static HRESULT WINAPI initializespy_QueryInterface(IInitializeSpy *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(&IID_IInitializeSpy, riid) ||
+            IsEqualIID(&IID_IUnknown, riid))
+    {
+        *obj = iface;
+        IInitializeSpy_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI initializespy_AddRef(IInitializeSpy *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI initializespy_Release(IInitializeSpy *iface)
+{
+    return 1;
+}
+
+static void imm_couninit_thread(IMMThreadData *thread_data)
+{
+    if (!thread_data->apt_initialized)
+        return;
+
+    thread_data->apt_initialized = FALSE;
+    CoUninitialize();
+}
+
+static HRESULT WINAPI initializespy_PreInitialize(IInitializeSpy *iface, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Application requested initialization of different apartment type. */
+    if (!(coinit & COINIT_APARTMENTTHREADED))
+        imm_couninit_thread(thread_data);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostInitialize(IInitializeSpy *iface, HRESULT hr, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Explicit initialization call should return S_OK first time. */
+    if (thread_data->apt_initialized && hr == S_FALSE && refs == 2)
+        hr = S_OK;
+
+    return hr;
+}
+
+static HRESULT WINAPI initializespy_PreUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Account for explicit uninitialization calls. */
+    if (thread_data->apt_initialized && refs == 1)
+        thread_data->apt_initialized = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    return S_OK;
+}
+
+static const IInitializeSpyVtbl initializespyvtbl =
+{
+    initializespy_QueryInterface,
+    initializespy_AddRef,
+    initializespy_Release,
+    initializespy_PreInitialize,
+    initializespy_PostInitialize,
+    initializespy_PreUninitialize,
+    initializespy_PostUninitialize,
+};
+
 static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
 {
     IMMThreadData *data;
@@ -253,6 +347,7 @@ static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
         if (data->threadID == thread) return data;
 
     data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data));
+    data->IInitializeSpy_iface.lpVtbl = &initializespyvtbl;
     data->threadID = thread;
     list_add_head(&ImmThreadDataList,&data->entry);
     TRACE("Thread Data Created (%x)\n",thread);
@@ -281,6 +376,7 @@ static void IMM_FreeThreadData(void)
             list_remove(&data->entry);
             LeaveCriticalSection(&threaddata_cs);
             IMM_DestroyContext(data->defaultContext);
+            imm_couninit_thread(data);
             HeapFree(GetProcessHeap(),0,data);
             TRACE("Thread Data Destroyed\n");
             return;
@@ -1627,6 +1723,32 @@ static BOOL needs_ime_window(HWND hwnd)
     return TRUE;
 }
 
+void WINAPI __wine_activate_window(HWND hwnd)
+{
+    IMMThreadData *thread_data;
+
+    TRACE("(%p)\n", hwnd);
+
+    if (!needs_ime_window(hwnd))
+        return;
+
+    thread_data = IMM_GetThreadData(hwnd, 0);
+    if (!thread_data)
+        return;
+
+    if (thread_data->disableIME || disable_ime)
+    {
+        TRACE("IME for this thread is disabled\n");
+        LeaveCriticalSection(&threaddata_cs);
+        return;
+    }
+
+    if (!thread_data->apt_initialized)
+        thread_data->apt_initialized = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
+
+    LeaveCriticalSection(&threaddata_cs);
+}
+
 /***********************************************************************
  *		__wine_register_window (IMM32.@)
  */
@@ -1656,6 +1778,8 @@ BOOL WINAPI __wine_register_window(HWND hwnd)
     /* Create default IME window */
     if (thread_data->windowRefs == 1)
     {
+        CoRegisterInitializeSpy(&thread_data->IInitializeSpy_iface, &thread_data->spy_cookie);
+
         /* Do not create the window inside of a critical section */
         LeaveCriticalSection(&threaddata_cs);
         new = CreateWindowExW( 0, szwIME, szwDefaultIME,
@@ -1697,8 +1821,11 @@ void WINAPI __wine_unregister_window(HWND hwnd)
           thread_data->windowRefs, thread_data->hwndDefault);
 
     /* Destroy default IME window */
-    if (thread_data->windowRefs == 0 && thread_data->hwndDefault)
+    if (thread_data->windowRefs == 0)
     {
+        CoRevokeInitializeSpy(thread_data->spy_cookie);
+        thread_data->spy_cookie.QuadPart = 0;
+        imm_couninit_thread(thread_data);
         to_destroy = thread_data->hwndDefault;
         thread_data->hwndDefault = NULL;
     }
diff --git a/dlls/imm32/imm32.spec b/dlls/imm32/imm32.spec
index 4197bb81e21..d9cdc794e9e 100644
--- a/dlls/imm32/imm32.spec
+++ b/dlls/imm32/imm32.spec
@@ -117,3 +117,4 @@
 @ stdcall __wine_get_ui_window(ptr)
 @ stdcall __wine_register_window(long)
 @ stdcall __wine_unregister_window(long)
+@ stdcall __wine_activate_window(long)
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index f1c883167ed..50b3323ae9f 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -156,6 +156,8 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
                       (LPARAM)previous );
         if (GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())
             PostMessageW( GetDesktopWindow(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+
+        imm_activate_window( hwnd );
     }
 
     /* now change focus if necessary */
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index c26c02a3537..5cbcc7db67d 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -43,6 +43,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(win);
 static HWND (WINAPI *imm_get_ui_window)(HKL);
 BOOL (WINAPI *imm_register_window)(HWND) = NULL;
 void (WINAPI *imm_unregister_window)(HWND) = NULL;
+void (WINAPI *imm_activate_window)(HWND) = NULL;
 
 /* MSIME messages */
 static UINT WM_MSIME_SERVICE;
@@ -567,6 +568,7 @@ BOOL WINAPI User32InitializeImmEntryTable(DWORD magic)
     imm_get_ui_window = (void*)GetProcAddress(imm32, "__wine_get_ui_window");
     imm_register_window = (void*)GetProcAddress(imm32, "__wine_register_window");
     imm_unregister_window = (void*)GetProcAddress(imm32, "__wine_unregister_window");
+    imm_activate_window = (void*)GetProcAddress(imm32, "__wine_activate_window");
     if (!imm_get_ui_window)
         FIXME("native imm32.dll not supported\n");
     return TRUE;
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 514cf6753f4..b86831d7d95 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -197,6 +197,7 @@ C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo)
 extern INT global_key_state_counter DECLSPEC_HIDDEN;
 extern BOOL (WINAPI *imm_register_window)(HWND) DECLSPEC_HIDDEN;
 extern void (WINAPI *imm_unregister_window)(HWND) DECLSPEC_HIDDEN;
+extern void (WINAPI *imm_activate_window)(HWND) DECLSPEC_HIDDEN;
 
 struct user_key_state_info
 {

From 8a781a3ab721a14fed0a8c1aaccd357cdd71d0ac Mon Sep 17 00:00:00 2001
From: Jactry Zeng <jzeng@codeweavers.com>
Date: Thu, 13 Dec 2018 22:21:34 +0800
Subject: [PATCH] gdi32: Add CJK font replacements.

---
 dlls/gdi32/freetype.c | 172 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 171 insertions(+), 1 deletion(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 0fc41f39021..1d721f50760 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -513,11 +513,22 @@ static const WCHAR external_fonts_reg_key[] = {'S','o','f','t','w','a','r','e','
 static const WCHAR Lucida_Sans_Unicode[] = {'L','u','c','i','d','a',' ','S','a','n','s',' ','U','n','i','c','o','d','e',0};
 static const WCHAR Microsoft_Sans_Serif[] = {'M','i','c','r','o','s','o','f','t',' ','S','a','n','s',' ','S','e','r','i','f',0 };
 static const WCHAR Tahoma[] = {'T','a','h','o','m','a',0};
+/* Japanese fonts */
 static const WCHAR MS_UI_Gothic[] = {'M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR atMS_UI_Gothic[] = {'@','M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR MS_PGothic_cp932[]= {0x30fb,0xff6d,0x30fb,0xff73,' ',0x30fb,0xff70,0x7e67,0xff74,0x7e67,0xff77,0x7e5d,0x30fb,0x3051,0};
+/* Simplified Chinese fonts */
 static const WCHAR SimSun[] = {'S','i','m','S','u','n',0};
-static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atSimSun[] = {'@','S','i','m','S','u','n',0};
+static const WCHAR Microsoft_YaHei[] = {'M','i','c','r','o','s','o','f','t',' ','Y','a','H','e','i',0};
+static const WCHAR LiSu[] = {'L','i','S','u',0};
+/* Traditional Chinese fonts */
 static const WCHAR PMingLiU[] = {'P','M','i','n','g','L','i','U',0};
+static const WCHAR atPMingLiU[] = {'@','P','M','i','n','g','L','i','U',0};
+/* Korean fonts */
 static const WCHAR Batang[] = {'B','a','t','a','n','g',0};
+static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atGulim[] = {'@','G','u','l','i','m',0};
 
 static const WCHAR arial[] = {'A','r','i','a','l',0};
 static const WCHAR bitstream_vera_sans[] = {'B','i','t','s','t','r','e','a','m',' ','V','e','r','a',' ','S','a','n','s',0};
@@ -2365,6 +2376,113 @@ static BOOL map_font_family(const WCHAR *orig, const WCHAR *repl)
     return FALSE;
 }
 
+static const WCHAR new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* Popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR vertical_new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static const WCHAR vertical_new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static struct font_replacements
+{
+    const WCHAR *replacements[4];
+    const int count;
+    const WCHAR *new_fonts;
+    const WCHAR *vertical_new_fonts;
+    BOOL *font_seen;
+} font_replacements_list[] =
+{
+    /* Simplified Chinese */
+    {
+        {
+            SimSun, atSimSun, Microsoft_YaHei, LiSu
+        }, 4, new_sc_fonts, vertical_new_sc_fonts, NULL
+    },
+    /* Traditional Chinese */
+    {
+        {
+            PMingLiU, atPMingLiU
+        }, 2, new_tc_fonts, vertical_new_tc_fonts, NULL
+    },
+    /* Japanese */
+    {
+        {
+            MS_UI_Gothic, atMS_UI_Gothic, MS_PGothic_cp932
+        }, 3, new_jp_fonts, vertical_new_jp_fonts, NULL
+    },
+    /* Korean */
+    {
+        {
+            Gulim, atGulim
+        }, 2, new_kr_fonts, vertical_new_kr_fonts, NULL
+    }
+};
+
 /***********************************************************
  * The replacement list is a way to map an entire font
  * family onto another family.  For example adding
@@ -2383,6 +2501,7 @@ static void LoadReplaceList(void)
     DWORD valuelen, datalen, i = 0, type, dlen, vlen;
     LPWSTR value;
     LPVOID data;
+    int replacement_count = sizeof(font_replacements_list)/sizeof(font_replacements_list[0]);
 
     /* @@ Wine registry key: HKCU\Software\Wine\Fonts\Replacements */
     if(RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts\\Replacements", &hkey) == ERROR_SUCCESS)
@@ -2401,6 +2520,25 @@ static void LoadReplaceList(void)
             /* "NewName"="Oldname" */
             if(!find_family_from_any_name(value))
             {
+                int j;
+
+                for (j = 0; j < replacement_count; j++)
+                {
+                    int k;
+
+                    struct font_replacements *replacement = &font_replacements_list[j];
+
+                    replacement->font_seen = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                                                       replacement->count * sizeof(BOOL));
+                    for (k = 0; k < replacement->count; k++)
+                    {
+                        if (!replacement->font_seen[k] && !lstrcmpW(value, replacement->replacements[k]))
+                        {
+                            replacement->font_seen[k] = TRUE;
+                            break;
+                        }
+                    }
+                }
                 if (type == REG_MULTI_SZ)
                 {
                     WCHAR *replace = data;
@@ -2421,6 +2559,38 @@ static void LoadReplaceList(void)
 	    dlen = datalen;
 	    vlen = valuelen;
 	}
+
+        for (i = 0; i < replacement_count; i++)
+        {
+            int j;
+            struct font_replacements *replacement = &font_replacements_list[i];
+
+            for (j = 0; j < replacement->count; j++)
+            {
+                if (!replacement->font_seen ||
+                    (!replacement->font_seen[j] && !find_family_from_any_name(replacement->replacements[j])))
+                {
+                    const WCHAR *replace;
+
+                    if (replacement->replacements[j][0] == '@')
+                        replace = replacement->vertical_new_fonts;
+                    else
+                        replace = replacement->new_fonts;
+
+                    while (*replace)
+                    {
+                        if (map_font_family(replacement->replacements[j], replace))
+                        {
+                            TRACE("Replace %s with %s\n", wine_dbgstr_w(replacement->replacements[j]),
+                                  wine_dbgstr_w(replace));
+                            break;
+                        }
+                        replace += strlenW(replace) + 1;
+                    }
+                }
+            }
+            HeapFree(GetProcessHeap(), 0, replacement->font_seen);
+        }
 	HeapFree(GetProcessHeap(), 0, data);
 	HeapFree(GetProcessHeap(), 0, value);
 	RegCloseKey(hkey);

From 17d19e1b23bce6fc6ff5b4e61131c9c58fd57ae5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:21:41 -0500
Subject: [PATCH] HACK: Don't build winemenubuilder

---
 configure          | 2 --
 configure.ac       | 1 -
 loader/wine.inf.in | 1 -
 3 files changed, 4 deletions(-)

diff --git a/configure b/configure
index 649a8917f54..4581015d576 100755
--- a/configure
+++ b/configure
@@ -1746,7 +1746,6 @@ enable_wineconsole
 enable_winedbg
 enable_winedevice
 enable_winefile
-enable_winemenubuilder
 enable_winemine
 enable_winemsibuilder
 enable_winepath
@@ -20315,7 +20314,6 @@ wine_fn_config_makefile programs/wineconsole enable_wineconsole
 wine_fn_config_makefile programs/winedbg enable_winedbg
 wine_fn_config_makefile programs/winedevice enable_winedevice
 wine_fn_config_makefile programs/winefile enable_winefile
-wine_fn_config_makefile programs/winemenubuilder enable_winemenubuilder
 wine_fn_config_makefile programs/winemine enable_winemine
 wine_fn_config_makefile programs/winemsibuilder enable_winemsibuilder
 wine_fn_config_makefile programs/winepath enable_winepath
diff --git a/configure.ac b/configure.ac
index 704da15f404..d4168e410bc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3998,7 +3998,6 @@ WINE_CONFIG_MAKEFILE(programs/wineconsole)
 WINE_CONFIG_MAKEFILE(programs/winedbg)
 WINE_CONFIG_MAKEFILE(programs/winedevice)
 WINE_CONFIG_MAKEFILE(programs/winefile)
-WINE_CONFIG_MAKEFILE(programs/winemenubuilder)
 WINE_CONFIG_MAKEFILE(programs/winemine)
 WINE_CONFIG_MAKEFILE(programs/winemsibuilder)
 WINE_CONFIG_MAKEFILE(programs/winepath)
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 2b049eb91f8..e6948a73427 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3598,7 +3598,6 @@ HKR,Parameters,"ServiceDll",,"%11%\schedsvc.dll"
 HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"Schedule"
 
 [Services]
-HKLM,%CurrentVersion%\RunServices,"winemenubuilder",2,"%11%\winemenubuilder.exe -a -r"
 HKLM,"System\CurrentControlSet\Services\Eventlog\Application",,16
 HKLM,"System\CurrentControlSet\Services\Eventlog\System","Sources",0x10000,""
 HKLM,"System\CurrentControlSet\Services\Tcpip\Parameters","DataBasePath",2,"%11%\drivers"

From aef0f1638ce13db03a4d3c0fe53972f44443c854 Mon Sep 17 00:00:00 2001
From: Patryk Obara <dreamer.tan@gmail.com>
Date: Fri, 26 Apr 2019 20:40:31 +0200
Subject: [PATCH] winex11: Fill WM_CLASS based on Steam appid

Some desktop environments (Gnome 3, Cinnamon) decide on an application
icon in the following order:

 - If the first string in WM_CLASS property can be correlated to
  a name or StartupWMClass key in a .desktop entry file, then
  the associated icon will be used.
 - If the second string in WM_CLASS property can be correlated to
  a name or StartupWMClass key in a .desktop entry file, then
  the associated icon will be used.
 - If the application has indicated an icon resource through WM_HINTS
  property, then the associated X window or pixmaps will be used.

Upstream Wine usually deals with this by placing a .desktop file with
StartupWMClass filled to match first string in WM_CLASS property
(which is the name of exe file being run).

Wine in Proton does not do it, but still puts "Wine" as second string,
therefore desktop environment can't differentiate between Wine in
Proton and Wine installed in OS.

By replacing "Wine" with "steam_app_<appid>" we force DE to fallback
to icon indicated by WM_HINTS (ico file embedded in exe file).
Steam can override this behaviour by installing properly crafted
.desktop entry file.  If SteamAppId environment variable is missing,
then generic "steam_proton" name is used instead.
---
 dlls/winex11.drv/window.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1ec7c706511..9ae3da3d4a2 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -870,10 +870,13 @@ static void set_initial_wm_hints( Display *display, Window window )
     /* class hints */
     if ((class_hints = XAllocClassHint()))
     {
-        static char wine[] = "Wine";
+        static char steam_proton[] = "steam_proton";
+        char proton_app_class[128];
+        const char *app_id = getenv("SteamAppId");
 
+        snprintf(proton_app_class, sizeof(proton_app_class), "steam_app_%s", app_id);
         class_hints->res_name = process_name;
-        class_hints->res_class = wine;
+        class_hints->res_class = app_id ? proton_app_class : steam_proton;
         XSetClassHint( display, window, class_hints );
         XFree( class_hints );
     }

From 012e9411ba504d2df7fad4920e71f4b38d89db52 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:20:17 +0200
Subject: [PATCH] winevulkan: Avoid returning 0 for swapchain maxImageCount.

Multiple games, Strange Brigade and No Man's Sky, didn't handle it
correctly in the past. 32 is reasonably high value, e.g.
DXGI_MAX_SWAP_CHAIN_BUFFERS is 16.

Conflicts:
	dlls/winevulkan/make_vulkan
	dlls/winevulkan/vulkan_thunks.c
	dlls/winevulkan/vulkan_thunks.h
---
 dlls/winevulkan/make_vulkan     |  2 +-
 dlls/winevulkan/vulkan.c        | 46 ++++++++++++++++++---------------
 dlls/winevulkan/vulkan_thunks.c |  5 ++++
 dlls/winevulkan/vulkan_thunks.h |  1 +
 4 files changed, 32 insertions(+), 22 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index d74fd82487b..579bd586abd 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -182,7 +182,7 @@ FUNCTION_OVERRIDES = {
     # VK_KHR_surface
     "vkDestroySurfaceKHR" : {"dispatch" : True, "driver" : True, "thunk" : True},
     "vkGetPhysicalDeviceSurfaceSupportKHR" : {"dispatch" : True, "driver" : True, "thunk" : True},
-    "vkGetPhysicalDeviceSurfaceCapabilitiesKHR" : {"dispatch" : True, "driver" : True, "thunk" : False},
+    "vkGetPhysicalDeviceSurfaceCapabilitiesKHR" : {"dispatch" : True, "driver" : True, "thunk" : False, "private_thunk" : True},
     "vkGetPhysicalDeviceSurfaceFormatsKHR" : {"dispatch" : True, "driver" : True, "thunk" : True},
     "vkGetPhysicalDeviceSurfacePresentModesKHR" : {"dispatch" : True, "driver" : True, "thunk" : True},
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 767cc54da80..e50e6d64784 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1249,6 +1249,31 @@ void WINAPI wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDev
     properties->externalSemaphoreFeatures = 0;
 }
 
+VkResult WINAPI wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice phys_dev,
+        VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *capabilities)
+{
+    VkResult res;
+    VkExtent2D user_res;
+
+    TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
+
+    res = thunk_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
+
+    /* HACK: It happened more than once that a Windows game didn't expect that maxImageCount can be
+     * set to 0. A value of 0 means that there is no limit on the number of images. */
+    if (res == VK_SUCCESS && capabilities->minImageCount && !capabilities->maxImageCount)
+        capabilities->maxImageCount = 32;
+
+    if(vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(NULL, &user_res, NULL)){
+        capabilities->currentExtent = user_res;
+        capabilities->minImageExtent = user_res;
+        capabilities->maxImageExtent = user_res;
+    }
+
+    return res;
+}
+
 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 {
     TRACE("%p, %u, %p\n", hinst, reason, reserved);
@@ -1296,27 +1321,6 @@ void *native_vkGetInstanceProcAddrWINE(VkInstance instance, const char *name)
     return vk_funcs->p_vkGetInstanceProcAddr(instance, name);
 }
 
-VkResult WINAPI wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
-{
-    VkResult res;
-    VkExtent2D user_res;
-
-    TRACE("%p, 0x%s, %p\n", physicalDevice, wine_dbgstr_longlong(surface), pSurfaceCapabilities);
-
-    res = physicalDevice->instance->funcs.p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice->phys_dev, surface, pSurfaceCapabilities);
-    if(res != VK_SUCCESS)
-        return res;
-
-    if(vk_funcs->query_fs_hack &&
-            vk_funcs->query_fs_hack(NULL, &user_res, NULL)){
-        pSurfaceCapabilities->currentExtent = user_res;
-        pSurfaceCapabilities->minImageExtent = user_res;
-        pSurfaceCapabilities->maxImageExtent = user_res;
-    }
-
-    return VK_SUCCESS;
-}
-
 VkResult WINAPI wine_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex)
 {
     struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)swapchain;
diff --git a/dlls/winevulkan/vulkan_thunks.c b/dlls/winevulkan/vulkan_thunks.c
index 3853ec45eaf..2c9b3396465 100644
--- a/dlls/winevulkan/vulkan_thunks.c
+++ b/dlls/winevulkan/vulkan_thunks.c
@@ -3726,6 +3726,11 @@ static void WINAPI wine_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhy
     physicalDevice->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice->phys_dev, pFormatInfo, pPropertyCount, pProperties);
 }
 
+VkResult thunk_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
+{
+    return physicalDevice->instance->funcs.p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice->phys_dev, surface, pSurfaceCapabilities);
+}
+
 VkResult WINAPI wine_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats)
 {
     TRACE("%p, 0x%s, %p, %p\n", physicalDevice, wine_dbgstr_longlong(surface), pSurfaceFormatCount, pSurfaceFormats);
diff --git a/dlls/winevulkan/vulkan_thunks.h b/dlls/winevulkan/vulkan_thunks.h
index ae6fa2678e6..85a85ca8b40 100644
--- a/dlls/winevulkan/vulkan_thunks.h
+++ b/dlls/winevulkan/vulkan_thunks.h
@@ -76,6 +76,7 @@ VkResult WINAPI wine_vkQueueSubmit(VkQueue queue, uint32_t submitCount, const Vk
 /* Private thunks */
 VkResult thunk_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) DECLSPEC_HIDDEN;
 VkResult thunk_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) DECLSPEC_HIDDEN;
+VkResult thunk_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) DECLSPEC_HIDDEN;
 
 typedef struct VkAcquireNextImageInfoKHR_host
 {

From 7e91b897e69854cb3afe761f48ef7c9b496ecf95 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:28:12 +0200
Subject: [PATCH] vulkan-1: Prefer built-in DLL.

Games may ship with their own Vulkan loader.
---
 dlls/vulkan-1/vulkan.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/dlls/vulkan-1/vulkan.c b/dlls/vulkan-1/vulkan.c
index d3b35603a17..4926cf9bf4f 100644
--- a/dlls/vulkan-1/vulkan.c
+++ b/dlls/vulkan-1/vulkan.c
@@ -32,10 +32,6 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     switch (reason)
     {
-        case DLL_WINE_PREATTACH:
-            /* Prefer native as it provides more functionality. */
-            return FALSE;
-
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinst);
             return TRUE;
