From 2fbe67c3f7eccb281e1312c3534898c2f247b717 Mon Sep 17 00:00:00 2001
From: telans <telans@protonmail.com>
Date: Sat, 13 Sep 2019 21:59:12 +0000
Subject: [PATCH] mangohud

---
 src/dxvk/dxvk_cpu.h              | 172 +++++++++++++++++++++++++++++++
 src/dxvk/hud/dxvk_hud.cpp        |  13 ++-
 src/dxvk/hud/dxvk_hud_config.cpp |   2 +
 src/dxvk/hud/dxvk_hud_config.h   |   2 +
 src/dxvk/hud/dxvk_hud_fps.cpp    |  68 ++++++++++--
 src/dxvk/hud/dxvk_hud_fps.h      |  11 ++
 src/dxvk/hud/dxvk_hud_stats.cpp  |  11 +-
 src/dxvk/hud/dxvk_hud_stats.h    |   4 +-
 8 files changed, 266 insertions(+), 17 deletions(-)
 create mode 100644 src/dxvk/dxvk_cpu.h

diff --git a/src/dxvk/dxvk_cpu.h b/src/dxvk/dxvk_cpu.h
new file mode 100644
index 00000000..b2c8736a
--- /dev/null
+++ b/src/dxvk/dxvk_cpu.h
@@ -0,0 +1,172 @@
+#include <cmath>
+#include <iomanip>
+#include <array>
+#include <vector>
+#include <algorithm>
+#include <iterator>
+#include <thread>
+#include <sstream>
+#include <fstream>
+using namespace std;
+
+const int NUM_CPU_STATES = 10;
+
+struct Cpus{
+  size_t num;
+  string name;
+  float value;
+  string output;
+};
+
+size_t numCpuCores = dxvk::thread::hardware_concurrency();
+size_t arraySize = numCpuCores + 1;
+std::vector<Cpus> cpuArray;
+
+void coreCounting(){
+  cpuArray.push_back({0, "CPU:"});
+  for (size_t i = 0; i < arraySize; i++) {
+    size_t offset = i;
+    stringstream ss;
+    ss << "CPU" << offset << ":";
+    string cpuNameString = ss.str();
+    cpuArray.push_back({i+1 , cpuNameString});
+  }
+}
+
+std::string m_cpuUtilizationString;
+
+enum CPUStates
+{
+	S_USER = 0,
+	S_NICE,
+	S_SYSTEM,
+	S_IDLE,
+	S_IOWAIT,
+	S_IRQ,
+	S_SOFTIRQ,
+	S_STEAL,
+	S_GUEST,
+	S_GUEST_NICE
+};
+
+typedef struct CPUData
+{
+	std::string cpu;
+	size_t times[NUM_CPU_STATES];
+} CPUData;
+
+void ReadStatsCPU(std::vector<CPUData> & entries)
+{
+	std::ifstream fileStat("/proc/stat");
+
+	std::string line;
+
+	const std::string STR_CPU("cpu");
+	const std::size_t LEN_STR_CPU = STR_CPU.size();
+	const std::string STR_TOT("tot");
+
+	while(std::getline(fileStat, line))
+	{
+		// cpu stats line found
+		if(!line.compare(0, LEN_STR_CPU, STR_CPU))
+		{
+			std::istringstream ss(line);
+
+			// store entry
+			entries.emplace_back(CPUData());
+			CPUData & entry = entries.back();
+
+			// read cpu label
+			ss >> entry.cpu;
+
+			if(entry.cpu.size() > LEN_STR_CPU)
+				entry.cpu.erase(0, LEN_STR_CPU);
+			else
+				entry.cpu = STR_TOT;
+
+			// read times
+			for(int i = 0; i < NUM_CPU_STATES; ++i)
+				ss >> entry.times[i];
+		}
+	}
+}
+
+size_t GetIdleTime(const CPUData & e)
+{
+	return	e.times[S_IDLE] +
+			e.times[S_IOWAIT];
+}
+
+size_t GetActiveTime(const CPUData & e)
+{
+	return	e.times[S_USER] +
+			e.times[S_NICE] +
+			e.times[S_SYSTEM] +
+			e.times[S_IRQ] +
+			e.times[S_SOFTIRQ] +
+			e.times[S_STEAL] +
+			e.times[S_GUEST] +
+			e.times[S_GUEST_NICE];
+}
+
+void PrintStats(const std::vector<CPUData> & entries1, const std::vector<CPUData> & entries2)
+{
+	const size_t NUM_ENTRIES = entries1.size();
+
+	for(size_t i = 0; i < NUM_ENTRIES; ++i)
+	{
+		const CPUData & e1 = entries1[i];
+		const CPUData & e2 = entries2[i];
+
+		const float ACTIVE_TIME	= static_cast<float>(GetActiveTime(e2) - GetActiveTime(e1));
+		const float IDLE_TIME	= static_cast<float>(GetIdleTime(e2) - GetIdleTime(e1));
+		const float TOTAL_TIME	= ACTIVE_TIME + IDLE_TIME;
+
+    cpuArray[i].value = (truncf(100.f * ACTIVE_TIME / TOTAL_TIME) * 10 / 10);
+	}
+}
+
+int getCpuUsage()
+{
+	std::vector<CPUData> entries1;
+	std::vector<CPUData> entries2;
+
+	// snapshot 1
+	ReadStatsCPU(entries1);
+
+	// 100ms pause
+	std::this_thread::sleep_for(std::chrono::milliseconds(100));
+
+	// snapshot 2
+	ReadStatsCPU(entries2);
+
+	// print output
+	PrintStats(entries1, entries2);
+
+	return 0;
+}
+
+
+void updateCpuStrings(){
+  for (size_t i = 0; i < arraySize; i++) {
+    size_t spacing = 10;
+    string value = to_string(cpuArray[i].value);
+    value.erase( value.find_last_not_of('0') + 1, std::string::npos );
+    size_t correctionValue = (spacing - cpuArray[i].name.length()) - value.length();
+    string correction = "";
+    for (size_t i = 0; i < correctionValue; i++) {
+          correction.append(" ");
+        }
+        stringstream ss;
+        if (i < 11) {
+          if (i == 0) {
+            ss << cpuArray[i].name << correction << cpuArray[i].value << "%";
+          } else {
+            ss << cpuArray[i].name << correction << cpuArray[i].value << "%";
+          }
+        } else {
+          ss << cpuArray[i].name << correction << cpuArray[i].value << "%";
+        }
+        cpuArray[i].output = ss.str();
+      }
+    }
\ No newline at end of file
diff --git a/src/dxvk/hud/dxvk_hud.cpp b/src/dxvk/hud/dxvk_hud.cpp
index 4fcd3bd2..4cb9f2dd 100644
--- a/src/dxvk/hud/dxvk_hud.cpp
+++ b/src/dxvk/hud/dxvk_hud.cpp
@@ -2,6 +2,8 @@
 #include <version.h>
 
 #include "dxvk_hud.h"
+float offset_x_float = 0.0;
+float offset_y_float = 0.0;
 
 namespace dxvk::hud {
   
@@ -60,6 +62,14 @@ namespace dxvk::hud {
   
   Rc<Hud> Hud::createHud(const Rc<DxvkDevice>& device) {
     std::string hudElements = env::getEnvVar("DXVK_HUD");
+    std::string offset_x = env::getEnvVar("DXVK_HUD_OFFSET_X");
+    std::string offset_y = env::getEnvVar("DXVK_HUD_OFFSET_Y");
+    
+    if (!offset_x.empty())
+      offset_x_float = stof(offset_x);
+    
+    if (!offset_y.empty())
+      offset_y_float = stof(offset_y);
 
     if (hudElements.empty())
       hudElements = device->config().hud;
@@ -84,7 +94,8 @@ namespace dxvk::hud {
 
 
   void Hud::renderHudElements(const Rc<DxvkContext>& ctx) {
-    HudPos position = { 8.0f, 24.0f };
+
+    HudPos position = { offset_x_float + 8.0f, offset_y_float + 24.0f };
     
     if (m_config.elements.test(HudElement::DxvkVersion)) {
       m_renderer.drawText(ctx, 16.0f,
diff --git a/src/dxvk/hud/dxvk_hud_config.cpp b/src/dxvk/hud/dxvk_hud_config.cpp
index fe1745bd..11227e67 100644
--- a/src/dxvk/hud/dxvk_hud_config.cpp
+++ b/src/dxvk/hud/dxvk_hud_config.cpp
@@ -16,6 +16,8 @@ namespace dxvk::hud {
     { "version",      HudElement::DxvkVersion       },
     { "api",          HudElement::DxvkClientApi     },
     { "compiler",     HudElement::CompilerActivity  },
+    { "mangogpuload", HudElement::GpuLoad           },
+    { "mangocpuload", HudElement::CpuLoad           },
   }};
   
   
diff --git a/src/dxvk/hud/dxvk_hud_config.h b/src/dxvk/hud/dxvk_hud_config.h
index 05a1e4b6..602333d1 100644
--- a/src/dxvk/hud/dxvk_hud_config.h
+++ b/src/dxvk/hud/dxvk_hud_config.h
@@ -22,6 +22,8 @@ namespace dxvk::hud {
     DxvkVersion       = 8,
     DxvkClientApi     = 9,
     CompilerActivity  = 10,
+    GpuLoad           = 11,
+    CpuLoad           = 12,
   };
   
   using HudElements = Flags<HudElement>;
diff --git a/src/dxvk/hud/dxvk_hud_fps.cpp b/src/dxvk/hud/dxvk_hud_fps.cpp
index f8cb6e7d..2b5811e8 100644
--- a/src/dxvk/hud/dxvk_hud_fps.cpp
+++ b/src/dxvk/hud/dxvk_hud_fps.cpp
@@ -1,7 +1,16 @@
 #include "dxvk_hud_fps.h"
+#include "dxvk_hud_stats.h"
+#include "../dxvk_cpu.h"
 
 #include <cmath>
 #include <iomanip>
+using namespace std;
+
+
+void printToLog(std::string file, string m_fpsString, string cpuUtil, string gpuUtil) {
+  fstream f(file, f.out | f.app);
+  f << m_fpsString << "," << cpuUtil << "," << gpuUtil << endl;
+}
 
 namespace dxvk::hud {
   
@@ -10,7 +19,6 @@ namespace dxvk::hud {
     m_fpsString ("FPS: "),
     m_prevFpsUpdate(Clock::now()),
     m_prevFtgUpdate(Clock::now()) {
-    
   }
   
   
@@ -29,11 +37,19 @@ namespace dxvk::hud {
     
     // Update FPS string
     if (elapsedFps.count() >= UpdateInterval) {
+      coreCounting();
+      dxvk::thread([this] () { getCpuUsage();});
+      updateCpuStrings();
+      m_cpuUtilizationString = str::format(cpuArray[0].output);
       const int64_t fps = (10'000'000ll * m_frameCount) / elapsedFps.count();
       m_fpsString = str::format("FPS: ", fps / 10, ".", fps % 10);
       
       m_prevFpsUpdate = now;
       m_frameCount = 0;
+      char const* logging = getenv("DXVK_LOG_TO_FILE");
+      if (!logging == 0){
+        printToLog(logging, str::format(fps / 10, ".", fps % 10), str::format(cpuArray[0].value), to_string(gpuLoad));
+      }
     }
     
     // Update frametime stuff
@@ -46,10 +62,18 @@ namespace dxvk::hud {
     const Rc<DxvkContext>&  context,
           HudRenderer&      renderer,
           HudPos            position) {
+    if (m_elements.test(HudElement::GpuLoad)) {
+      position = this->renderGpuText(
+        context, renderer, position);
+      }
+    if (m_elements.test(HudElement::CpuLoad)) {
+      position = this->renderCpuText(
+        context, renderer, position);
+    }
     if (m_elements.test(HudElement::Framerate)) {
       position = this->renderFpsText(
         context, renderer, position);
-    }
+      }
     
     if (m_elements.test(HudElement::Frametimes)) {
       position = this->renderFrametimeGraph(
@@ -60,18 +84,42 @@ namespace dxvk::hud {
   }
   
   
-  HudPos HudFps::renderFpsText(
-    const Rc<DxvkContext>&  context,
-          HudRenderer&      renderer,
-          HudPos            position) {
+  
+  HudPos HudFps::renderGpuText(
+  const Rc<DxvkContext>&  context,
+        HudRenderer&      renderer,
+        HudPos            position) {
+  renderer.drawText(context, 16.0f,
+    { position.x, position.y },
+    { 1.0f, 1.0f, 1.0f, 1.0f },
+    m_gpuLoadString);
+
+  return HudPos { position.x, position.y + 24 };
+}  
+
+HudPos HudFps::renderCpuText(
+const Rc<DxvkContext>&  context,
+      HudRenderer&      renderer,
+      HudPos            position) {
+renderer.drawText(context, 16.0f,
+  { position.x, position.y },
+  { 1.0f, 1.0f, 1.0f, 1.0f },
+  m_cpuUtilizationString);
+
+return HudPos { position.x, position.y + 24 };
+}  
+
+HudPos HudFps::renderFpsText(
+  const Rc<DxvkContext>&  context,
+  HudRenderer&      renderer,
+  HudPos            position) {
     renderer.drawText(context, 16.0f,
       { position.x, position.y },
       { 1.0f, 1.0f, 1.0f, 1.0f },
       m_fpsString);
-    
-    return HudPos { position.x, position.y + 24 };
-  }
-  
+      
+      return HudPos { position.x, position.y + 24 };
+    }
   
   HudPos HudFps::renderFrametimeGraph(
     const Rc<DxvkContext>&  context,
diff --git a/src/dxvk/hud/dxvk_hud_fps.h b/src/dxvk/hud/dxvk_hud_fps.h
index c8c4b984..ac89397f 100644
--- a/src/dxvk/hud/dxvk_hud_fps.h
+++ b/src/dxvk/hud/dxvk_hud_fps.h
@@ -43,12 +43,23 @@ namespace dxvk::hud {
     
     std::array<float, NumDataPoints>  m_dataPoints  = {};
     uint32_t                          m_dataPointId = 0;
+
+    HudPos renderGpuText(
+      const Rc<DxvkContext>&  context,
+      HudRenderer&      renderer,
+      HudPos            position);
+      
+    HudPos renderCpuText(
+      const Rc<DxvkContext>&  context,
+            HudRenderer&      renderer,
+            HudPos            position);
     
     HudPos renderFpsText(
       const Rc<DxvkContext>&  context,
             HudRenderer&      renderer,
             HudPos            position);
     
+    
     HudPos renderFrametimeGraph(
       const Rc<DxvkContext>&  context,
             HudRenderer&      renderer,
diff --git a/src/dxvk/hud/dxvk_hud_stats.cpp b/src/dxvk/hud/dxvk_hud_stats.cpp
index 995f186b..be8a5eb7 100644
--- a/src/dxvk/hud/dxvk_hud_stats.cpp
+++ b/src/dxvk/hud/dxvk_hud_stats.cpp
@@ -1,5 +1,7 @@
 #include "dxvk_hud_stats.h"
 
+std::string m_gpuLoadString = "GPU: ";
+uint64_t gpuLoad;
 namespace dxvk::hud {
   
   HudStats::HudStats(HudElements elements)
@@ -24,7 +26,7 @@ namespace dxvk::hud {
 
     // GPU load is a bit more complex than that since
     // we don't want to update this every frame
-    if (m_elements.test(HudElement::StatGpuLoad))
+    if (m_elements.test(HudElement::GpuLoad) || m_elements.test(HudElement::StatGpuLoad))
       this->updateGpuLoad();
   }
   
@@ -70,8 +72,8 @@ namespace dxvk::hud {
       uint64_t busyTicks = ticks > m_diffGpuIdleTicks
         ? uint64_t(ticks - m_diffGpuIdleTicks)
         : uint64_t(0);
-
-      m_gpuLoadString = str::format("GPU: ", (100 * busyTicks) / ticks, "%");
+      gpuLoad = 100 * busyTicks / ticks;
+      m_gpuLoadString = str::format("GPU:   ", (100 * busyTicks) / ticks, "%");
     }
   }
 
@@ -224,7 +226,8 @@ namespace dxvk::hud {
       HudElement::StatPipelines,
       HudElement::StatMemory,
       HudElement::StatGpuLoad,
-      HudElement::CompilerActivity);
+      HudElement::CompilerActivity,
+      HudElement::GpuLoad);
   }
   
 }
diff --git a/src/dxvk/hud/dxvk_hud_stats.h b/src/dxvk/hud/dxvk_hud_stats.h
index 227f600c..b7d740f1 100644
--- a/src/dxvk/hud/dxvk_hud_stats.h
+++ b/src/dxvk/hud/dxvk_hud_stats.h
@@ -7,6 +7,8 @@
 #include "dxvk_hud_config.h"
 #include "dxvk_hud_renderer.h"
 
+extern std::string m_gpuLoadString;
+extern uint64_t gpuLoad;
 namespace dxvk::hud {
   
   /**
@@ -44,8 +46,6 @@ namespace dxvk::hud {
     uint64_t m_prevGpuIdleTicks = 0;
     uint64_t m_diffGpuIdleTicks = 0;
     
-    std::string m_gpuLoadString = "GPU: ";
-
     void updateGpuLoad();
     
     HudPos printDrawCallStats(
-- 
2.23.0

